(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{419:function(t,e,v){"use strict";v.r(e);var a=v(11),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"etcd"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#etcd"}},[t._v("#")]),t._v(" etcd")]),t._v(" "),v("h2",{attrs:{id:"介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://etcd.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("etcd"),v("OutboundLink")],1),t._v("是使用Go语言开发的一个开源的、高可用的分布式key-value存储系统，可以用于配置共享和服务的注册和发现。")]),t._v(" "),v("p",[t._v("类似项目有zookeeper和consul。")]),t._v(" "),v("p",[t._v("etcd具有以下特点：")]),t._v(" "),v("ul",[v("li",[t._v("完全复制：集群中的每个节点都可以使用完整的存档")]),t._v(" "),v("li",[t._v("高可用性：Etcd可用于避免硬件的单点故障或网络问题")]),t._v(" "),v("li",[t._v("一致性：每次读取都会返回跨多主机的最新写入")]),t._v(" "),v("li",[t._v("简单：包括一个定义良好、面向用户的API（gRPC）")]),t._v(" "),v("li",[t._v("安全：实现了带有可选的客户端证书身份验证的自动化TLS")]),t._v(" "),v("li",[t._v("快速：每秒10000次写入的基准速度")]),t._v(" "),v("li",[t._v("可靠：使用Raft算法实现了强一致、高可用的服务存储目录")])]),t._v(" "),v("h2",{attrs:{id:"etcd应用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#etcd应用场景"}},[t._v("#")]),t._v(" etcd应用场景")]),t._v(" "),v("h3",{attrs:{id:"服务发现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务发现"}},[t._v("#")]),t._v(" 服务发现")]),t._v(" "),v("p",[t._v("服务发现要解决的也是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听 udp 或 tcp 端口，并且通过名字就可以查找和连接。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://i.loli.net/2021/05/13/fu3CijMHIVF6kmy.png",alt:"img"}})]),t._v(" "),v("ul",[v("li",[t._v("service requestor 服务的请求方")]),t._v(" "),v("li",[t._v("service provider 服务的提供方")]),t._v(" "),v("li",[t._v("service registry 服务的注册方")])]),t._v(" "),v("p",[t._v("服务器注册方能检测到服务提供方是否在线")]),t._v(" "),v("h3",{attrs:{id:"配置中心"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#配置中心"}},[t._v("#")]),t._v(" 配置中心")]),t._v(" "),v("p",[t._v("将一些配置信息放到 etcd 上进行集中管理。")]),t._v(" "),v("p",[t._v("这类场景的使用方式通常是这样：应用在启动的时候主动从 etcd 获取一次配置信息，同时，在 etcd 节点上注册一个 Watcher 并等待，以后每次配置有更新的时候，etcd 都会实时通知订阅者，以此达到获取最新配置信息的目的。")]),t._v(" "),v("h3",{attrs:{id:"分布式锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[t._v("#")]),t._v(" 分布式锁")]),t._v(" "),v("p",[t._v("因为 etcd 使用 Raft 算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("保持独占即所有获取锁的用户最终只有一个可以得到")]),t._v("。etcd 为此提供了一套实现分布式锁原子操作 CAS（"),v("code",[t._v("CompareAndSwap")]),t._v("）的 API。通过设置"),v("code",[t._v("prevExist")]),t._v("值，可以保证在多个节点同时去创建某个目录时，只有一个成功。而创建成功的用户就可以认为是获得了锁。")]),t._v(" "),v("li",[t._v("控制时序，即所有想要获得锁的用户都会被安排执行，但是"),v("strong",[t._v("获得锁的顺序也是全局唯一的，同时决定了执行顺序")]),t._v("。etcd 为此也提供了一套 API（自动创建有序键），对一个目录建值时指定为"),v("code",[t._v("POST")]),t._v("动作，这样 etcd 会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用 API 按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://i.loli.net/2021/05/13/AlpI1T28f4LH57Z.png",alt:"img"}})]),t._v(" "),v("h2",{attrs:{id:"知识拓展"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#知识拓展"}},[t._v("#")]),t._v(" 知识拓展")]),t._v(" "),v("h3",{attrs:{id:"raft-协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#raft-协议"}},[t._v("#")]),t._v(" Raft 协议")]),t._v(" "),v("ul",[v("li",[t._v("选举")]),t._v(" "),v("li",[t._v("。。。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);